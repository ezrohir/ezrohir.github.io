# Core Animation Advanced Techniques 图层性能

### 文本
`CATextLayer` `UILable` 都是直接将文本绘制在图层的寄宿图中.
事实上这两种方式用了完全不同的渲染方式:在iOS 6及之前,
`UILabel` 用WebKit的HTML渲染引擎来绘制文本,
而 `CATextLayer` 用的是Core Text.后者渲染更迅速,所以在所有需要绘制大量文本的情形下都优先使用它吧.

不论如何,尽可能地避免改变那些包含文本的视图的frame,因为这样做的话文本就需要重绘.

### 光栅化
`shouldRasterize` 属性会将图层绘制到一个屏幕之外的图像.
然后这个图像将会被缓存起来并绘制到实际图层的contents和子图层,如果有很多的子图层或者有复杂的效果应用,
这样做就会比重绘所有事务的所有帧划得来得多.
但是光栅化原始图像需要时间,而且还会消耗额外的内存.

### 离屏渲染
触发离屏渲染
- 圆角
- 图层蒙板
- 阴影
屏幕外渲染和我们启用光栅化时相似,除了它并没有像光栅化图层那么消耗大,子图层并没有被影响到,
而且结果也没有被缓存,所以不会有长期的内存占用.但是,如果太多图层在屏幕外渲染依然会影响到性能.


###　CAShapeLayer
`cornerRadius` `maskToBounds` 独立作用的时候都不会有太大的性能问题,但是当他俩结合在一起,
就触发了屏幕外渲染.

### 混合和过渡绘制
GPU每一帧可以绘制的像素有一个最大限制(就是所谓的fill rate),
这个情况下可以轻易地绘制整个屏幕的所有像素.但是如果由于重叠图层的关系需要不停地重绘同一区域的话.掉帧就可能发生了.

GPU会放弃绘制那些完全被其他图层遮挡的像素,但是要计算出一个图层是否被遮挡也是相当复杂并且会消耗处理器资源.
同样,合并不同图层的透明重叠像素（即混合）消耗的资源也是相当客观的.所以为了加速处理进程,不到必须时刻不要使用透明图层.
任何情况下,应该这样:
- 给视图的 `backgroundColor` 属性设置一个固定的，不透明的颜色.
- 设置 `opaque` 属性为YES.

如果是文本的话,一个白色背景的 `UILabel` （或者其他颜色）会比透明背景要更高效.
