## Core Animation Advanced Techniques 性能调优
### CPU VS GPU
### 动画的舞台
动画和屏幕上组合的图层实际上被一个单独的进程管理,而不是你的应用程序.这个进程就是所谓的渲染服务.
在iOS6之后的版本中叫做 `BackBoard`.

运行一段动画,这个过程主要分为四个阶段:
- 布局 准备你的视图/图层的层级关系,设置图层属性（位置，背景色，边框等等.
- 显示 这是图层的寄宿图片被绘制的阶段.绘制有可能涉及你的-drawRect:和-drawLayer:inContext:方法的调用路径.
- 准备 这是 Core Animation 准备发送动画数据到渲染服务的阶段.同时也是 Core Animation 将要执行一些别的事务例如解码动画过程中将要显示的图片的时间点.
- 提交 Core Animation 打包所有图层和动画属性,然后通过 IPC（内部处理通信）发送到渲染服务进行显示.

在你的App外,一旦打包的图层和动画到达渲染服务进程,他们会被反序列化形成另外一个叫渲染树的图层树,渲染服务将对懂哈ud每一帧做如下工作:
- 对所有的图层属性计算中间值,设置 OpenGL 几何形状(纹理化的三角形)来执行渲染.
- 在屏幕上悬软可见的三角形.

前五个阶段都是 CPU 在软件层面处理,最后一个被 GPU 执行.对于自己真正能控制的只有前两个阶段: 布局和显示.

### GPU 相关操作
CGU 用来采集图片和形状(三角板),于心变换,应用纹理和混合然后把他们输送到屏幕上.
宽泛的说,大多数 `CALayer` 的属性都是用 GPU 来绘制,
比如如果你设置图层背景或者边框的颜色,那么这些可以通过着色的三角板实时绘制出来.
如果对一个contents属性设置一张图片,然后裁剪它 - 它就会被纹理的三角形绘制出来,而不需要软件层面做任何绘制.

但是有些事情会降低GPU图层绘制:
- 太多的集合结构
- 重绘 主要由重叠的半透明图层引起.
- 离屏绘制 发生在当不能直接在屏幕上绘制,并且必须绘制到离屏图片的上下文中的时候.离屏绘制发生在基于CPU或者是GPU的渲染,
  或者是为离屏图片分配额外内存,以及切换绘制上下文,这些都会降低GPU性能.
  对于特定图层效果的使用,比如圆角,图层遮罩,阴影或者是图层光栅化都会强制 Core Animation 提前玄幻图层的礼品绘制.
- 过大的图片 如果视图绘制超出GPU支持的2048x2048或者4096x4096尺寸的纹理,就必须要用CPU在图层每次显示之前对图片预处理,同样也会降低性能.

### CPU 相关操作
CPU 主要耗时操作
- 布局计算
- 视图延迟加载
- Core Graphics绘制 如果对视图实现了 `-drawRect:` 方法,或者 `CALayerDelegate` 的 `-drawLayer:inContext:` 方法,那么在绘制任何东西
  之前都会产生一个巨大的性能开销.为了支持对图层内容的任意绘制, Core ANimation 必须创见一个内存中等大小的寄宿图片.然后一旦绘制结束之后 ,
  必须把图片数据通过IPC传到渲染服务器.
- 解压图片

当图层被打包发送到渲染服务器之后,CPU仍然要做如下工作:为了显示屏幕上的图层,Core ANimation必须对悬软树种的每个可见图层通过 OpenGL 循环转换成纹理三角板.
由于GPU并不知晓Core Animation图层的任何结构,所以必须要由CPU做这些事情.
这里CPU涉及的工作和图层个数成正比,所以如果在你的层级关系中有太多的图层,就会导致CPU没一帧的渲染,即使这些事情不是你的应用程序可控的.


### IO 相关操作
