<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ez&#39;s Blog</title>
    <atom:link href="https://ezrohir.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <link>https://ezrohir.github.io/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Fri, 31 Jul 2015 16:51:27 +0800</pubDate>
    
      <item>
        <title>Runtime随感</title>
        <link>https://ezrohir.github.io/2015/07/28/Runtime%E9%9A%8F%E6%84%9F.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2015/07/28/Runtime%E9%9A%8F%E6%84%9F.html</guid>
        <description>&lt;h2 id=&quot;runtime-&quot;&gt;Runtime 念念叨叨&lt;/h2&gt;

&lt;h3 id=&quot;property-&quot;&gt;不能动态添加 property 问题&lt;/h3&gt;
&lt;p&gt;这个其实还是很好理解的, property 可以理解为对实例变量的 get set 方法.关键点在实例变量,编译的时候实例变量的布局已经确定.
至于动态添加方法 Class 结构中有对于 指针数组,用于存储方法列表的指针.
至于实例变量,是能动态添加的,通过 Runtime 的 Associated Objects 函数添加实例变量,印象中是添加在一个全局的管理器中.&lt;/p&gt;

&lt;h3 id=&quot;receiver-message--objective-c-runtime-&quot;&gt;从 [receiver message] 引发的对 Objective-C Runtime 的理解&lt;/h3&gt;
&lt;p&gt;对于执行某个方法,最简单的模型是能直接找到函数指针.这样就不能是Runtime了,因为在编译的时候就知道了要掉哪个地址的函数.
站在运行时看, receiver 是对象是实例, message 可以直观上理解为函数指针,但我也是上过小学的人,这么理解肯定不对,好歹也是个函数指针的封装,还有些额外信息,看起来问题复杂了.&lt;/p&gt;

&lt;p&gt;事实上 Objective-C 语言做了某些拓展,增加了某些数据结构,比如 receiver 是指向 objc_class 的指针,黑魔法都在 objc_class
结构体中.站在面向对象的角度看,姑且将 objc_class 当成一个类, objc_class类中 有俩重要指针, 一个指向 superClass ,一个指向
metaClass ,还有一些其他重要的指针数组,比如装实例变量的数组,装方法的数组,等等.但事实上 objc_class 是一个结构体,所有面向
对象都是一个幌子,站在底层角度看,是如何优雅的实现一个结构体.&lt;/p&gt;

&lt;p&gt;OK, [receiver message] 顺利成章的理解为:运行的时候 receiver 指针去它指向的结构体中的方法列表中找 message 函数体封装.
表达真不行,啰嗦了半天好像没说到点子上.事实上找 message 过程比较曲折,对象的方法列表找,没找到?那么上面提到的俩重要指针
出场了,既然有指向 metaClass 的指针,会在这里寻找类方法, 在 superClass 指向的对象中寻找实例方法.这种机制就是Runtime的一部分,
因为这个message在这时候,才可能被定位到.&lt;/p&gt;

&lt;p&gt;上面提到的只是 Runtime 的一部分,还有些容错机制,当然还有其他机制比如 Method Swizzling.现在的重点是容错机制.
理想情况下 message 会被找到,但是万一没有了?Runtime 提供了一些补救的措施,这也是 Runtime 的一部分.有三个重要环节,
动态方法解析,重定向,方法转发.&lt;/p&gt;

&lt;p&gt;如果 message 对应的结构体封装没找到,首先执行动态方法解析,给一个改过自新的机会,&lt;code&gt;+ (BOOL)resolveInstanceMethod:(SEL)aSEL&lt;/code&gt;,
Runtime 问码农,你愿意给改类动态添加对应的message吗? 我不愿意.OK,Runtime还是会再给一次机会. &lt;code&gt;- (id)forwardingTargetForSelector:(SEL)aSelector&lt;/code&gt; 将被调用, Runtime 的期望值降低了,你不干那你把活仍给其他对象干总OK吧.
码农比较倔,就不扔给其他对象,本是同根生,相煎何太急,就返回 &lt;code&gt;nil&lt;/code&gt; 怎么滴. Runtime 还是比较温和的, &lt;code&gt;- (void)forwardInvocation:(NSInvocation *)anInvocation&lt;/code&gt; 方法转发的调用被抛出,不过已经很无语了.不坚持的码农不是好码农,就是不处理,代价就是App崩溃了.用户在骂,尼玛,这破软件
请的什么临时工啊.&lt;/p&gt;

&lt;p&gt;以上是 Runtime 的主要流程,看起来比较枯燥,但是用的好,普通码农和优秀码农的区别就出来了.经典案例, &lt;a href=&quot;http://tech.glowing.com/cn/method-swizzling-aop/&quot;&gt;Method Swizzling 和 AOP 实践&lt;/a&gt;,看完整个人就不好.他们怎么能成角儿啊，得敲多少行代码，我什么时候才能成角儿啊.(出自霸王别姬).&lt;/p&gt;

&lt;p&gt;发现今天思维异常活跃,一气呵成,感觉非常好.PS,这只是自己念念叨叨,随感而发. Runtime 这块,很多蚂蝗的文章写的深入浅出.&lt;/p&gt;

&lt;h3 id=&quot;app&quot;&gt;App不能添加动态库的问题&lt;/h3&gt;
&lt;p&gt;悬而未决,现在的认识只是系统安全限制,技术上添加动态库是没问题的.这个需要研究下.&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Jul 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>App优化的一些总结</title>
        <link>https://ezrohir.github.io/2015/01/04/iOS%20App%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E7%9A%84%E4%BC%98%E5%8C%96.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2015/01/04/iOS%20App%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E7%9A%84%E4%BC%98%E5%8C%96.html</guid>
        <description>&lt;h2 id=&quot;ios-app&quot;&gt;iOS App滑动卡顿的优化&lt;/h2&gt;
&lt;p&gt;iOS8以后,发现App卡爆了,于是用Instruments分析了下,下面是一些使用总结.&lt;/p&gt;

&lt;h3 id=&quot;core-animation&quot;&gt;Core Animation&lt;/h3&gt;
&lt;p&gt;滑动帧率很低时,当为GPU瓶颈时,
&lt;img src=&quot;http://7u2qbg.com1.z0.glb.clouddn.com/insrument_CoremeAnimation2015-01-27 10.24.26.png&quot; alt=&quot;Insrument_CoreAnimation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时候一般下面俩值数值很高.
+ &lt;strong&gt;&lt;em&gt;Renderer Utilization&lt;/em&gt;&lt;/strong&gt; 这个值一般大于50%有可能会掉帧,主要是因为视图过度混合(重叠的半透明图层)或者离屏渲染引起的.
+ &lt;strong&gt;&lt;em&gt;Tiler Utilization&lt;/em&gt;&lt;/strong&gt;这个值大于50%也会降低帧率,造成的原因是图层太多.&lt;/p&gt;

&lt;h3 id=&quot;time-profiler&quot;&gt;Time Profiler&lt;/h3&gt;
&lt;p&gt;滑动时帧率很低时,有可能是CPU瓶颈,这时候一般都能在Time Profiler中看到,下图是正常情况,当App的CPU利用率接近渲染进程(backboardd),是时候优化Time Profiler中高危份子了.
&lt;img src=&quot;http://7u2qbg.com1.z0.glb.clouddn.com/instrument_timeProfiler%202015-01-27%2010.24.56.png&quot; alt=&quot;instrument_timeProfiler&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;io&quot;&gt;IO瓶颈&lt;/h3&gt;
&lt;p&gt;待续&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;下面都是不错的参考&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.hrchen.com/2013/05/performance-with-instruments/&quot;&gt;Instruments的基本使用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios&quot;&gt;Offscreen rendering, Blending, layout的触发条件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 04 Jan 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>集成Crashlytics</title>
        <link>https://ezrohir.github.io/2014/12/19/%E9%9B%86%E6%88%90crashlytics.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2014/12/19/%E9%9B%86%E6%88%90crashlytics.html</guid>
        <description>&lt;h2 id=&quot;crashlytics&quot;&gt;Crashlytics集成&lt;/h2&gt;
&lt;p&gt;相比友盟的crash统计，感觉Crashlytics专业得多，但集成过程中，坑还是蛮多的.&lt;/p&gt;

&lt;h3 id=&quot;xcodecrashlyticscrash&quot;&gt;真机链接Xcode调试Crashlytics是收集不到Crash日志的&lt;/h3&gt;

&lt;p&gt;真机链接Xcode调试中，crash处理会被Xcode的debugger工具接管，虽然在Editor Scheme中可以设置禁用debugger，但最好别这么干，Crashlytics角色是crash收集工具（虽然官网说可以扔掉Xcode debugger了），一般调试还是Xcode的debugger更方便。但对于某些不稳定bug，Crashlytics好像更方便点.&lt;/p&gt;

&lt;h3 id=&quot;debug-mode&quot;&gt;debug-mode&lt;/h3&gt;
&lt;p&gt;Crashlytics 的SDK提供&lt;code&gt;debugMode&lt;/code&gt;属性，初次集成的时候打开debugMode属性终端会输出reports上传到服务器的过程，很方便.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Crashlytics sharedInstance].debugMode = YES;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;crashlytics-1&quot;&gt;友盟也会拦截掉Crashlytics&lt;/h3&gt;
&lt;p&gt;App crash后，抢hook的真不少.一般App都会用到友盟统计，友盟统计默认开启crash统计，会造成Crashlytics拿不到crash信息，解决如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[MobClick setCrashReportEnabled:NO];
[MobClick startWithAppkey:YOURKEY reportPolicy:YOURPOLICY channelId:YOURCHANNELID];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后强烈建议集成到slack中，真的很方便.
PS.千万别用平时用的邮箱注册Crashlytics，如果App不是很稳定的话.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Dec 2014 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>URL Encoding 的坑</title>
        <link>https://ezrohir.github.io/2014/07/28/URL_Encoding%E7%9A%84%E5%9D%91.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2014/07/28/URL_Encoding%E7%9A%84%E5%9D%91.html</guid>
        <description>&lt;h2 id=&quot;url-encoding&quot;&gt;URL Encoding&lt;/h2&gt;
&lt;p&gt;URLs can only be sent over the Internet using the &lt;a href=&quot;http://www.w3schools.com/charsets/ref_html_ascii.asp&quot;&gt;ASCII character-set&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since URLs often contain characters outside the ASCII set, the URL has to be converted into a valid ASCII format.&lt;/p&gt;

&lt;p&gt;URL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits.&lt;/p&gt;

&lt;p&gt;URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.&lt;/p&gt;

&lt;p&gt;掉坑是因为App内动态控制 url ,服务端返回的 url 带中文字符, NSString类提供了 &lt;code&gt;stringByAddingPercentEscapesUsingEncoding:&lt;/code&gt; 方法.该方法能编码非 url 的字符,但对于类似 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 的 reserved characters 没有做处理,也就是没有严格遵守 url 应该编码成 ASCII 字符的规范.
网上给的通用String的Category:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSString *)urlencode {
    NSMutableString *output = [NSMutableString string];
    const unsigned char *source = (const unsigned char *)[self UTF8String];
    int sourceLen = strlen((const char *)source);
    for (int i = 0; i &amp;lt; sourceLen; ++i) {
        const unsigned char thisChar = source[i];
        if (thisChar == &#39; &#39;){
            [output appendString:@&quot;+&quot;];
        } else if (thisChar == &#39;.&#39; || thisChar == &#39;-&#39; ||
                   thisChar == &#39;_&#39; || thisChar == &#39;~&#39; ||
                   (thisChar &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; thisChar &amp;lt;= &#39;z&#39;) ||
                   (thisChar &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; thisChar &amp;lt;= &#39;Z&#39;) ||
                   (thisChar &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; thisChar &amp;lt;= &#39;9&#39;)) {
            [output appendFormat:@&quot;%c&quot;, thisChar];
        } else {
            [output appendFormat:@&quot;%%%02X&quot;, thisChar];
        }
  }
  return output;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 28 Jul 2014 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>Duplicate Symbol问题</title>
        <link>https://ezrohir.github.io/2014/07/02/Duplicate-Symbol%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2014/07/02/Duplicate-Symbol%E9%97%AE%E9%A2%98.html</guid>
        <description>&lt;h2 id=&quot;duplicate-symbol-xxx-&quot;&gt;Duplicate Symbol xxx 原因和解决&lt;/h2&gt;
&lt;p&gt;今天引入新的静态库时发生Duplicate Symbol xxx，检查了下工程配置，other linker flag-&amp;gt; -all_load.(此处是铺垫)。然后网上参考了些资料，见尾部。&lt;/p&gt;

&lt;h3 id=&quot;duplicate-symbol&quot;&gt;Duplicate Symbol原因&lt;/h3&gt;
&lt;p&gt;看报错描述大意知道是俩框架某个Symbol冲突了，那么问题来了，这个冲突的Symbol代表的是什么，函数还是类？其实仔细想想就答案了，Objective-C 这种runtime机制的语言Symbol怎么可能是函数，苹果文档也解释了这点:
&amp;gt;Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. &lt;/p&gt;

&lt;h3 id=&quot;duplicate-symbol-1&quot;&gt;Duplicate Symbol解决&lt;/h3&gt;
&lt;p&gt;OK，现在说说看到的解决方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;工具解压静态库，删除相同编译文件，重新打包。如果的时间多想玩玩或者老板让这么干(我不是在黑老板)，&lt;a href=&quot;http://atnan.com/blog/2012/01/12/avoiding-duplicate-symbol-errors-during-linking-by-removing-classes-from-static-libraries&quot;&gt;参考在这&lt;/a&gt;	.&lt;/li&gt;
  &lt;li&gt;修改other linker flag，常见的other linker flag有&lt;code&gt;-ObjC &lt;/code&gt;,&lt;code&gt;-all_load &lt;/code&gt;,&lt;code&gt;-force_load &lt;/code&gt;.
    &lt;ul&gt;
      &lt;li&gt;-ObjC  -ObjC allow the static library to use objective-c specific stuffs like kvc or categories.&lt;/li&gt;
      &lt;li&gt;-all_load   Loads all members of static archive libraries.&lt;/li&gt;
      &lt;li&gt;-force_load   -all_load forces all members of all archives to be loaded. This option allows you to target a specific archive.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看解释真没发现-ObjC和-all_load有什么区别，不过事实上other linker flag-&amp;gt; -all_load就会报Duplicate Symbol xxx，而other linker flag-&amp;gt; –ObjC编译通过，只能大胆假设-ObjC下linker会链接所有静态库文件，但不管多少静态库，有没有重复，反正静态库中文件保证只被链接一次，有点GCD中dispatch_once的味道。在求证过程中对-all_load的描述都指向&lt;a href=&quot;https://developer.apple.com/library/mac/qa/qa1490/_index.html&quot;&gt;Technical Q&amp;amp;A QA1490&lt;/a&gt;，但是该Document已修改，感觉苹果应该修正了这个问题。&lt;/p&gt;

&lt;p&gt;PS -all_load引入的原因
&amp;gt;Important: For 64-bit and iPhone OS applications, there is a linker bug that prevents -ObjC from loading objects files from static libraries that contain only categories and no classes. The workaround is to use the -allload or -forceload flags.&lt;/p&gt;

&lt;p&gt;Anyway,&lt;code&gt;-ObjC&lt;/code&gt;,&lt;code&gt;-force_load &lt;/code&gt;都是快速解决问题的方法。至于&lt;code&gt;-ObjC &lt;/code&gt;与&lt;code&gt;-all_load &lt;/code&gt;,&lt;code&gt;-force_load &lt;/code&gt;的区别，有空再研究下。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考引用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/qa/qa1490/_index.html&quot;&gt;Technical Q&amp;amp;A QA1490
Building Objective-C static libraries with categories&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://atnan.com/blog/2012/01/12/avoiding-duplicate-symbol-errors-during-linking-by-removing-classes-from-static-libraries&quot;&gt;avoiding-duplicate-symbol-errors-during-linking-by-removing-classes-from-static-libraries&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2567498/objective-c-categories-in-static-library&quot;&gt;Objective-C categories in static library&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Jul 2014 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>阅读笔记索引</title>
        <link>https://ezrohir.github.io/2014/03/03/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2014/03/03/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E7%B4%A2%E5%BC%95.html</guid>
        <description>&lt;h2 id=&quot;section&quot;&gt;图形相关&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ezrohir/ezrohir.github.io/blob/master/snippet/Core-Animation-Advanced-Techniques.md&quot;&gt;Core-Animation-Advanced-Techniques-寄宿图&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ezrohir/ezrohir.github.io/blob/master/snippet/Core-Animation-Advanced-Techniques-图层几何学.md&quot;&gt;Core-Animation-Advanced-Techniques-图层几何学&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ezrohir/ezrohir.github.io/blob/master/snippet/Core-Animation-Advanced-Techniques-变换.md&quot;&gt;Core-Animation-Advanced-Techniques-变换&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ezrohir/ezrohir.github.io/blob/master/snippet/Core-Animation-Advanced-Techniques-视觉效果.md&quot;&gt;Core-Animation-Advanced-Techniques-视觉效果&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ezrohir/ezrohir.github.io/blob/master/snippet/Core-Animation-Advanced-Techniques隐式动画.md&quot;&gt;Core-Animation-Advanced-Techniques-隐式动画&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ezrohir/ezrohir.github.io/blob/master/snippet/Core-Animation-Advanced-Techniques显示动画.md&quot;&gt;Core-Animation-Advanced-Techniques-显式动画&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 03 Mar 2014 00:00:00 +0800</pubDate>
      </item>
    
  </channel>
</rss>
