<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ez&#39;s Blog</title>
    <atom:link href="https://ezrohir.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <link>https://ezrohir.github.io/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Tue, 28 Jul 2015 15:20:48 +0800</pubDate>
    
      <item>
        <title>App优化的一些总结</title>
        <link>https://ezrohir.github.io/2015/01/04/iOS%20App%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E7%9A%84%E4%BC%98%E5%8C%96.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2015/01/04/iOS%20App%E6%BB%91%E5%8A%A8%E5%8D%A1%E9%A1%BF%E7%9A%84%E4%BC%98%E5%8C%96.html</guid>
        <description>&lt;h2 id=&quot;ios-app&quot;&gt;iOS App滑动卡顿的优化&lt;/h2&gt;
&lt;p&gt;iOS8以后,发现App卡爆了,于是用Instruments分析了下,下面是一些使用总结.&lt;/p&gt;

&lt;h3 id=&quot;core-animation&quot;&gt;Core Animation&lt;/h3&gt;
&lt;p&gt;滑动帧率很低时,当为GPU瓶颈时,
&lt;img src=&quot;http://7u2qbg.com1.z0.glb.clouddn.com/insrument_CoremeAnimation2015-01-27 10.24.26.png&quot; alt=&quot;Insrument_CoreAnimation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时候一般下面俩值数值很高.
+ &lt;strong&gt;&lt;em&gt;Renderer Utilization&lt;/em&gt;&lt;/strong&gt; 这个值一般大于50%有可能会掉帧,主要是因为视图过度混合(重叠的半透明图层)或者离屏渲染引起的.
+ &lt;strong&gt;&lt;em&gt;Tiler Utilization&lt;/em&gt;&lt;/strong&gt;这个值大于50%也会降低帧率,造成的原因是图层太多.&lt;/p&gt;

&lt;h3 id=&quot;time-profiler&quot;&gt;Time Profiler&lt;/h3&gt;
&lt;p&gt;滑动时帧率很低时,有可能是CPU瓶颈,这时候一般都能在Time Profiler中看到,下图是正常情况,当App的CPU利用率接近渲染进程(backboardd),是时候优化Time Profiler中高危份子了.
&lt;img src=&quot;http://7u2qbg.com1.z0.glb.clouddn.com/instrument_timeProfiler%202015-01-27%2010.24.56.png&quot; alt=&quot;instrument_timeProfiler&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;io&quot;&gt;IO瓶颈&lt;/h3&gt;
&lt;p&gt;待续&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;下面都是不错的参考&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.hrchen.com/2013/05/performance-with-instruments/&quot;&gt;Instruments的基本使用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/13158796/what-triggers-offscreen-rendering-blending-and-layoutsubviews-in-ios&quot;&gt;Offscreen rendering, Blending, layout的触发条件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 04 Jan 2015 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>集成Crashlytics</title>
        <link>https://ezrohir.github.io/2014/12/19/%E9%9B%86%E6%88%90crashlytics.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2014/12/19/%E9%9B%86%E6%88%90crashlytics.html</guid>
        <description>&lt;h2 id=&quot;crashlytics&quot;&gt;Crashlytics集成&lt;/h2&gt;
&lt;p&gt;相比友盟的crash统计，感觉Crashlytics专业得多，但集成过程中，坑还是蛮多的.&lt;/p&gt;

&lt;h3 id=&quot;xcodecrashlyticscrash&quot;&gt;真机链接Xcode调试Crashlytics是收集不到Crash日志的&lt;/h3&gt;

&lt;p&gt;真机链接Xcode调试中，crash处理会被Xcode的debugger工具接管，虽然在Editor Scheme中可以设置禁用debugger，但最好别这么干，Crashlytics角色是crash收集工具（虽然官网说可以扔掉Xcode debugger了），一般调试还是Xcode的debugger更方便。但对于某些不稳定bug，Crashlytics好像更方便点.&lt;/p&gt;

&lt;h3 id=&quot;debug-mode&quot;&gt;debug-mode&lt;/h3&gt;
&lt;p&gt;Crashlytics 的SDK提供&lt;code&gt;debugMode&lt;/code&gt;属性，初次集成的时候打开debugMode属性终端会输出reports上传到服务器的过程，很方便.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Crashlytics sharedInstance].debugMode = YES;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;crashlytics-1&quot;&gt;友盟也会拦截掉Crashlytics&lt;/h3&gt;
&lt;p&gt;App crash后，抢hook的真不少.一般App都会用到友盟统计，友盟统计默认开启crash统计，会造成Crashlytics拿不到crash信息，解决如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[MobClick setCrashReportEnabled:NO];
[MobClick startWithAppkey:YOURKEY reportPolicy:YOURPOLICY channelId:YOURCHANNELID];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后强烈建议集成到slack中，真的很方便.
PS.千万别用平时用的邮箱注册Crashlytics，如果App不是很稳定的话.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Dec 2014 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>URL Encoding 的坑</title>
        <link>https://ezrohir.github.io/2014/07/28/URL_Encoding%E7%9A%84%E5%9D%91.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2014/07/28/URL_Encoding%E7%9A%84%E5%9D%91.html</guid>
        <description>&lt;h2 id=&quot;url-encoding&quot;&gt;URL Encoding&lt;/h2&gt;
&lt;p&gt;URLs can only be sent over the Internet using the &lt;a href=&quot;http://www.w3schools.com/charsets/ref_html_ascii.asp&quot;&gt;ASCII character-set&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since URLs often contain characters outside the ASCII set, the URL has to be converted into a valid ASCII format.&lt;/p&gt;

&lt;p&gt;URL encoding replaces unsafe ASCII characters with a “%” followed by two hexadecimal digits.&lt;/p&gt;

&lt;p&gt;URLs cannot contain spaces. URL encoding normally replaces a space with a plus (+) sign or with %20.&lt;/p&gt;

&lt;p&gt;掉坑是因为App内动态控制 url ,服务端返回的 url 带中文字符, NSString类提供了 &lt;code&gt;stringByAddingPercentEscapesUsingEncoding:&lt;/code&gt; 方法.该方法能编码非 url 的字符,但对于类似 &lt;code&gt;/&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; 的 reserved characters 没有做处理,也就是没有严格遵守 url 应该编码成 ASCII 字符的规范.
网上给的通用String的Category:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSString *)urlencode {
    NSMutableString *output = [NSMutableString string];
    const unsigned char *source = (const unsigned char *)[self UTF8String];
    int sourceLen = strlen((const char *)source);
    for (int i = 0; i &amp;lt; sourceLen; ++i) {
        const unsigned char thisChar = source[i];
        if (thisChar == &#39; &#39;){
            [output appendString:@&quot;+&quot;];
        } else if (thisChar == &#39;.&#39; || thisChar == &#39;-&#39; ||
                   thisChar == &#39;_&#39; || thisChar == &#39;~&#39; ||
                   (thisChar &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; thisChar &amp;lt;= &#39;z&#39;) ||
                   (thisChar &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; thisChar &amp;lt;= &#39;Z&#39;) ||
                   (thisChar &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; thisChar &amp;lt;= &#39;9&#39;)) {
            [output appendFormat:@&quot;%c&quot;, thisChar];
        } else {
            [output appendFormat:@&quot;%%%02X&quot;, thisChar];
        }
  }
  return output;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 28 Jul 2014 00:00:00 +0800</pubDate>
      </item>
    
      <item>
        <title>Duplicate Symbol问题</title>
        <link>https://ezrohir.github.io/2014/07/02/Duplicate-Symbol%E9%97%AE%E9%A2%98.html</link>
        <guid isPermaLink="true">https://ezrohir.github.io/2014/07/02/Duplicate-Symbol%E9%97%AE%E9%A2%98.html</guid>
        <description>&lt;h2 id=&quot;duplicate-symbol-xxx-&quot;&gt;Duplicate Symbol xxx 原因和解决&lt;/h2&gt;
&lt;p&gt;今天引入新的静态库时发生Duplicate Symbol xxx，检查了下工程配置，other linker flag-&amp;gt; -all_load.(此处是铺垫)。然后网上参考了些资料，见尾部。&lt;/p&gt;

&lt;h3 id=&quot;duplicate-symbol&quot;&gt;Duplicate Symbol原因&lt;/h3&gt;
&lt;p&gt;看报错描述大意知道是俩框架某个Symbol冲突了，那么问题来了，这个冲突的Symbol代表的是什么，函数还是类？其实仔细想想就答案了，Objective-C 这种runtime机制的语言Symbol怎么可能是函数，苹果文档也解释了这点:
&amp;gt;Objective-C does not define linker symbols for each function (or method, in Objective-C) - instead, linker symbols are only generated for each class. &lt;/p&gt;

&lt;h3 id=&quot;duplicate-symbol-1&quot;&gt;Duplicate Symbol解决&lt;/h3&gt;
&lt;p&gt;OK，现在说说看到的解决方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;工具解压静态库，删除相同编译文件，重新打包。如果的时间多想玩玩或者老板让这么干(我不是在黑老板)，&lt;a href=&quot;http://atnan.com/blog/2012/01/12/avoiding-duplicate-symbol-errors-during-linking-by-removing-classes-from-static-libraries&quot;&gt;参考在这&lt;/a&gt;	.&lt;/li&gt;
  &lt;li&gt;修改other linker flag，常见的other linker flag有&lt;code&gt;-ObjC &lt;/code&gt;,&lt;code&gt;-all_load &lt;/code&gt;,&lt;code&gt;-force_load &lt;/code&gt;.
    &lt;ul&gt;
      &lt;li&gt;-ObjC  -ObjC allow the static library to use objective-c specific stuffs like kvc or categories.&lt;/li&gt;
      &lt;li&gt;-all_load   Loads all members of static archive libraries.&lt;/li&gt;
      &lt;li&gt;-force_load   -all_load forces all members of all archives to be loaded. This option allows you to target a specific archive.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;看解释真没发现-ObjC和-all_load有什么区别，不过事实上other linker flag-&amp;gt; -all_load就会报Duplicate Symbol xxx，而other linker flag-&amp;gt; –ObjC编译通过，只能大胆假设-ObjC下linker会链接所有静态库文件，但不管多少静态库，有没有重复，反正静态库中文件保证只被链接一次，有点GCD中dispatch_once的味道。在求证过程中对-all_load的描述都指向&lt;a href=&quot;https://developer.apple.com/library/mac/qa/qa1490/_index.html&quot;&gt;Technical Q&amp;amp;A QA1490&lt;/a&gt;，但是该Document已修改，感觉苹果应该修正了这个问题。&lt;/p&gt;

&lt;p&gt;PS -all_load引入的原因
&amp;gt;Important: For 64-bit and iPhone OS applications, there is a linker bug that prevents -ObjC from loading objects files from static libraries that contain only categories and no classes. The workaround is to use the -allload or -forceload flags.&lt;/p&gt;

&lt;p&gt;Anyway,&lt;code&gt;-ObjC&lt;/code&gt;,&lt;code&gt;-force_load &lt;/code&gt;都是快速解决问题的方法。至于&lt;code&gt;-ObjC &lt;/code&gt;与&lt;code&gt;-all_load &lt;/code&gt;,&lt;code&gt;-force_load &lt;/code&gt;的区别，有空再研究下。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考引用&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/library/mac/qa/qa1490/_index.html&quot;&gt;Technical Q&amp;amp;A QA1490
Building Objective-C static libraries with categories&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://atnan.com/blog/2012/01/12/avoiding-duplicate-symbol-errors-during-linking-by-removing-classes-from-static-libraries&quot;&gt;avoiding-duplicate-symbol-errors-during-linking-by-removing-classes-from-static-libraries&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/2567498/objective-c-categories-in-static-library&quot;&gt;Objective-C categories in static library&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Jul 2014 00:00:00 +0800</pubDate>
      </item>
    
  </channel>
</rss>
